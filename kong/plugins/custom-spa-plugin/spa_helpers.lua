-- Library imports
local kong             = kong
local workspaces       = require "kong.workspaces"
local cjson            = require "cjson"
local workspace_config = require "kong.portal.workspace_config"
local constants        = require "kong.constants"
local file_helpers     = require "kong.portal.file_helpers"
local PORTAL           = constants.WORKSPACE_CONFIG.PORTAL
local validate_path    = require "kong.db.schema.entities.files".validate_path

-- This function can accept test and return that text wrapped in escaped quotes
function escape_text(text)
  return ("\""..text.."\"")
end
-- Check if the portal is enabled in both the config and the workspace
function is_portal_enabled_and_workspace_activated()
  local ws = workspaces.get_workspace()
  local opts = { explicitly_ws = true }
  local enabled_in_ws = workspace_config.retrieve(PORTAL, ws, opts)
  local enabled_in_conf = kong.configuration.portal
  -- When testing with Pongo this ENV va is provided by the test framework
  -- Through Pongo it is impossible to enable the portal in the config
  local KONG_IN_TESTING = os.getenv("KONG_IS_TESTING") == "1"
  if not (enabled_in_conf or KONG_IN_TESTING) or not enabled_in_ws then
    return false
  end
  return true
end
-- Ask database for a file by a path
function get_file_by_path(path)
  local file, err, err_t = kong.db.files:select_by_path(path)
  return file, err, err_t
end
-- Returns the extension of a file string with regex
function get_file_extension(file)
  return file_helpers.get_ext(file)
end
-- Prints a table as string to the Kong default log phase
function print_table_as_string(start_str, tbl, max, pos)
  if not pos then 
    print("[custom-spa-plugin] Starting print_table_as_string")
    pos = 0
   end
  if not max then max = 1 end
  if pos+1 > max then return end

  for a, b in pairs(tbl) do
    local lo = tostring(b)
    local str_loc = start_str.."."..a
    print("["..str_loc.."]: "..lo)
    if type(b) == "table" then
      print_table_as_string(str_loc, b, max, pos+1)
    end
  end
end
-- Custom implementation for integrating the Kong Cache with the Files DB
-- The cache_key is a unique identifier generated by the database like "files:specs/httpbin.json:::::3a8c476f-c5aa-4b5e-b532-79a592d8492e"
function load_file_by_key(cache_key)
  -- This is basic string manipulation to extract text BETWEEN the firsy two insantances of ":"
  local pos_a, pos_b = cache_key:find(":.-:")
  local extracted_path = cache_key:sub((pos_a+1), (pos_b-1))  -- +1 offsets beginning while -1 removes tail
  local file, err = kong.db.files:select_by_path(extracted_path)
  if not file then
    return nil, err
  end
  return file
end
-- This is a custom function used by the access block to build an HTTP return packet
function success_exit(body, content_type)
  kong.response.exit(200, body, {["Content-Type"] = content_type})
end

-- Tis helpers file does not use a typical module layout to ignore stateful functions
-- Instead it is a file of localized functions which we return the pointers
return {
  escape_text                               = escape_text,
  is_portal_enabled_and_workspace_activated = is_portal_enabled_and_workspace_activated,
  get_file_by_path                          = get_file_by_path,
  get_file_extension                        = get_file_extension,
  print_table_as_string                     = print_table_as_string,
  load_file_by_key                          = load_file_by_key,
  success_exit                              = success_exit,
  validate_path                             = validate_path
}